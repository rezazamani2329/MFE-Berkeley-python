# -*- coding: utf-8 -*-
"""hw3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11JjSolRFmDJfDBI7DNBH1g-lySymNH-v

**How to Approach This Assignment**

Write the code yourself. This homework (and the Advanced Python lectures) introduces core coding concepts and mental models used in coding interviews. Many companies still conduct classic coding interviews and do not allow AI during them. You need to build these problem-solving muscles yourself.

**Use AI as a tutor, not a coder:**

Use Claude or ChatGPT to learn unfamiliar concepts - ask lots of questions!
Frequently test your own understanding by explaining concepts back to the AI
Have the AI quiz you to check your comprehension
Do NOT give the assignment to AI or have it write your code
After you get it working: You're welcome to use AI to assess your code, teach you improvements, or give you more practice problems. We recommend this!

**Part 1: Memoization with Expiry**

What is Memoization?
Memoization is a technique where you cache (store) the results of expensive function calls and return the cached result when the same inputs occur again. This avoids redundant computation.

Why it matters:

Interviews: Memoization is a common optimization technique in coding interviews, especially for dynamic programming problems
Real-world: Caching is everywhere - web servers cache database queries, browsers cache images, APIs cache responses. Understanding caching fundamentals is essential.
Your Task
Implement memorize_3s, a decorator that:

Caches function results per argument (e.g., f(1) and f(2) are cached separately)
Cache expires after 3 seconds - if 3+ seconds have passed since caching, call the function again
"""

import time
from typing import List

# ==== Part 1 =====
def memorize_3s(func):
    """
    Implement a memoization decorator that caches function results for 3 seconds.
    After 3 seconds, the cache should expire and the function should be called again.
    """
    ... # to implement
    cache = {}
    def wrapper(*args, **kwargs):
        current_time = time.time()
        cache_key = args
        if cache_key in cache:
            cached_result, cached_time = cache[cache_key]
            if current_time - cached_time < 3:
                return cached_result
        result = func(*args, **kwargs)
        cache[cache_key] = (result, current_time)
        return result
    return wrapper  # placeholder - remove this line when implementing


@memorize_3s
def identity(x):
    print('this function is called')
    return x


# ==== Part 2 =====

# Definition of a binary tree node
class Node:
    def __init__(self, key, left=None, right=None):
        # Store the value of the node
        self.val = key
        # Pointer to left child
        self.left = left
        # Pointer to right child
        self.right = right


# =========================
# PRE-ORDER TRAVERSAL
# Order: Root → Left → Right
# =========================

# Recursive pre-order traversal
# Takes the root of a binary tree and returns a list of node values
def pre_order_recursion(root: Node) -> List[str]:
    result = []

    # Helper function to perform recursion
    def _preorder(node):
        if node:
            # Visit root first
            result.append(node.val)
            # Traverse left subtree
            _preorder(node.left)
            # Traverse right subtree
            _preorder(node.right)

    _preorder(root)
    return result


# Iterative pre-order traversal using a stack
def pre_order_iteration(root: Node) -> List[str]:
    result = []

    # If tree is empty, return empty list
    if not root:
        return result

    # Stack simulates the recursive call stack
    stack = [root]

    while stack:
        node = stack.pop()
        # Visit node
        result.append(node.val)

        # Push right child first so left child is processed first
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result


# =========================
# IN-ORDER TRAVERSAL
# Order: Left → Root → Right
# =========================

# Recursive in-order traversal
def in_order_recursion(root: Node) -> List[str]:
    result = []

    def _inorder(node):
        if node:
            # Traverse left subtree
            _inorder(node.left)
            # Visit root
            result.append(node.val)
            # Traverse right subtree
            _inorder(node.right)

    _inorder(root)
    return result


# Iterative in-order traversal using a stack
def in_order_iteration(root: Node) -> List[str]:
    result = []

    if not root:
        return result

    stack = []
    current = root

    # Continue until all nodes are processed
    while stack or current:
        # Reach the leftmost node
        while current:
            stack.append(current)
            current = current.left

        # Process node
        current = stack.pop()
        result.append(current.val)

        # Move to right subtree
        current = current.right

    return result


# =========================
# POST-ORDER TRAVERSAL
# Order: Left → Right → Root
# =========================

# Recursive post-order traversal
def post_order_recursion(root: Node) -> List[str]:
    result = []

    def _postorder(node):
        if node:
            # Traverse left subtree
            _postorder(node.left)
            # Traverse right subtree
            _postorder(node.right)
            # Visit root
            result.append(node.val)

    _postorder(root)
    return result


# Iterative post-order traversal using one stack
def post_order_iteration(root: Node) -> List[str]:
    result = []

    if not root:
        return result

    stack = [root]
    last_visited = None

    while stack:
        current = stack[-1]

        # If current is a leaf node OR children already visited
        if (
            (not current.left and not current.right) or
            (last_visited and (last_visited == current.left or last_visited == current.right))
        ):
            stack.pop()
            result.append(current.val)
            last_visited = current
        else:
            # Push children to stack (right first)
            if current.right:
                stack.append(current.right)
            if current.left:
                stack.append(current.left)

    return result



# ====== test cases below ======
# DO NOT MODIFY THIS SECTION
if __name__ == "__main__":
    # Part 1 tests
    print("Testing Part 1: Memoization")
    identity(1)  # there should be a print
    identity(1)  # there should be no print (cached)
    time.sleep(3)
    identity(1)  # there should be a print (cache expired)
    print("Part 1 complete\n")

    # Part 2 tests
    print("Testing Part 2: Binary Tree Traversal")
    root = Node('F',
        left=Node(
            'B',
            left=Node('A'),
            right=Node('D', left=Node('C'), right=Node('E')),
        ),
        right=Node('G', right=Node('I', left=Node('H')))
    )

    assert pre_order_recursion(root) == pre_order_iteration(root) == ['F', 'B', 'A', 'D', 'C', 'E', 'G', 'I', 'H']
    assert in_order_recursion(root) == in_order_iteration(root) == ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    assert post_order_recursion(root) == post_order_iteration(root) == ['A', 'C', 'E', 'D', 'B', 'H', 'I', 'G', 'F']

    print("All tests passed!")